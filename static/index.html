<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Live Gesture + Air Handwriting</title>

  <style>
    body {
      margin: 0;
      text-align: center;
      background: #f6f6f6;
      font-family: Arial, sans-serif;
    }

    /* Make the video + canvas responsive full width */
    .wrap {
      position: relative;
      width: 100vw;
      max-width: 100vw;
      height: calc(100vh - 200px);
      /* leave space for buttons */
      margin: 0 auto;
      overflow: hidden;
    }

    video,
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;

      /* MIRROR FIX */
      transform: scaleX(-1);
      transform-origin: center;

      border: none;
      border-radius: 0;
    }


    button {
      margin-top: 20px;
      padding: 10px 20px;
      font-size: 18px;
      border-radius: 6px;
      cursor: pointer;
    }

    #status {
      margin-top: 15px;
      font-size: 22px;
      font-weight: bold;
      color: #111;
    }
  </style>
</head>

<body>

  <h2>üñê Live Gesture + ‚úçÔ∏è Air-Handwriting Detection</h2>

  <div class="wrap">
    <video id="video" autoplay playsinline muted></video>

    <!-- MediaPipe landmarks -->
    <canvas id="overlay"></canvas>

    <!-- Air-handwriting layer -->
    <canvas id="drawCanvas"></canvas>
  </div>

  <br />

  <!-- Buttons -->
  <button onclick="goFullscreen()">Fullscreen</button>

  <button onclick="sendStroke()">Recognize Handwriting</button>
  <button onclick="clearScreen()">Clear Screen</button>
  <span id="writeIndicator" style="
    margin-left: 15px;
    padding: 6px 14px;
    border-radius: 20px;
    font-weight: bold;
    background: #ff4d4d;
    color: white;
  ">
    Writing OFF
  </span>

  <script type="module">
    import {
      HandLandmarker,
      FilesetResolver,
      DrawingUtils
    } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest";

    const video = document.getElementById("video");
    const canvas = document.getElementById("overlay");
    const ctx = canvas.getContext("2d");

    const drawCanvas = document.getElementById("drawCanvas");
    const drawCtx = drawCanvas.getContext("2d");

    // --- Air writing state ---
    let drawing = false;
    let stroke = [];
    let smoothX = null;
    let smoothY = null;
    let medianBufferX = [];
    let medianBufferY = [];
    const MEDIAN_SIZE = 5; // more = smoother
    let writeIndicatorON = false;


    const SMOOTHING = 0.7; // 0.0 = no smoothing, 0.9 = very smooth


    let handLandmarker;
    let running = false;

    function median(values) {
      if (values.length === 0) return 0;
      let sorted = [...values].sort((a, b) => a - b);
      let mid = Math.floor(sorted.length / 2);
      return sorted[mid];
    }
    function updateIndicator(state) {
      const indicator = document.getElementById("writeIndicator");
      writeIndicatorON = state;

      if (state) {
        indicator.innerText = "Writing ON";
        indicator.style.background = "#28a745"; // green
      } else {
        indicator.innerText = "Writing OFF";
        indicator.style.background = "#ff4d4d"; // red
      }
    }

    // ==========================
    // Initialize MediaPipe
    // ==========================
    async function init() {
      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
      );

      handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath:
            "https://storage.googleapis.com/mediapipe-assets/hand_landmarker.task",
        },
        numHands: 1,
        runningMode: "VIDEO",
      });

      startCamera();
    }

    async function startCamera() {
      const stream = await navigator.mediaDevices.getUserMedia({ video: true });
      video.srcObject = stream;

      video.onloadeddata = () => {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;

        drawCanvas.width = video.videoWidth;
        drawCanvas.height = video.videoHeight;

        running = true;
        detect();
      };
    }

    function countFingersUp(points) {
      let up = 0;

      // Thumb (mirrored video ‚Üí reverse comparison)
      if (points[4].x > points[3].x) up++;

      // Other fingers: upward check
      if (points[8].y < points[6].y) up++;   // index
      if (points[12].y < points[10].y) up++; // middle
      if (points[16].y < points[14].y) up++; // ring
      if (points[20].y < points[18].y) up++; // pinky

      return up;
    }



    // ==========================
    // MAIN DETECT LOOP
    // ==========================
    function detect() {
      if (!running) return;

      const results = handLandmarker.detectForVideo(video, performance.now());

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (results.landmarks && results.landmarks.length > 0) {
        const points = results.landmarks[0];

        // üî• Detect number of fingers up
        let fingers = countFingersUp(points);

        // ==============================
        // ‚ú® INDICATOR CONTROL (NEW)
        // ==============================

        // üñê All fingers open ‚Üí indicator OFF
        if (fingers === 5 || fingers === 0) {
          updateIndicator(false);
          drawing = false;
          stroke = [];

          smoothX = null;
          smoothY = null;
          medianBufferX = [];
          medianBufferY = [];
        }

        // ‚òùÔ∏è Only index finger up ‚Üí indicator ON
        if (fingers === 1) {
          updateIndicator(true);
        }

        // ==============================
        // ‚úçÔ∏è Writing start/stop logic
        // ==============================

        // Start writing only when indicator is ON
        if (fingers === 1 && !drawing && writeIndicatorON) {
          drawing = true;
          stroke = [];
          smoothX = null;
          smoothY = null;
          medianBufferX = [];
          medianBufferY = [];
        }

        // Safety stop (indicator OFF)
        if (!writeIndicatorON && drawing) {
          drawing = false;
        }

        const utils = new DrawingUtils(ctx);

        // Draw mediapipe landmarks
        utils.drawLandmarks(points);
        utils.drawConnectors(points, HandLandmarker.HAND_CONNECTIONS);

        // ====================================
        // ‚úçÔ∏è AIR HANDWRITING FEATURE (UNCHANGED)
        // ====================================
        const indexTip = points[8];

        // video aspect ratio
        const videoAspect = video.videoWidth / video.videoHeight;
        const canvasAspect = drawCanvas.width / drawCanvas.height;

        let renderW, renderH, offsetX = 0, offsetY = 0;

        if (videoAspect > canvasAspect) {
          renderW = drawCanvas.width;
          renderH = drawCanvas.width / videoAspect;
          offsetY = (drawCanvas.height - renderH) / 2;
        } else {
          renderH = drawCanvas.height;
          renderW = drawCanvas.height * videoAspect;
          offsetX = (drawCanvas.width - renderW) / 2;
        }

        let rawX = indexTip.x * renderW + offsetX;
        let rawY = indexTip.y * renderH + offsetY;

        // ---- MEDIAN FILTER ----
        medianBufferX.push(rawX);
        medianBufferY.push(rawY);

        if (medianBufferX.length > MEDIAN_SIZE) medianBufferX.shift();
        if (medianBufferY.length > MEDIAN_SIZE) medianBufferY.shift();

        let filtX = median(medianBufferX);
        let filtY = median(medianBufferY);

        // ---- LOW-PASS FILTER ----
        if (smoothX === null) {
          smoothX = filtX;
          smoothY = filtY;
        }

        smoothX = smoothX * SMOOTHING + filtX * (1 - SMOOTHING);
        smoothY = smoothY * SMOOTHING + filtY * (1 - SMOOTHING);

        const x = smoothX;
        const y = smoothY;

        // ‚úçÔ∏è DRAW ONLY IF INDICATOR ON
        if (drawing && writeIndicatorON) {
          stroke.push({ x, y });

          drawCtx.lineWidth = 4;
          drawCtx.lineCap = "round";
          drawCtx.strokeStyle = "#00ff00";

          if (stroke.length > 1) {
            const prev = stroke[stroke.length - 2];
            drawCtx.beginPath();
            drawCtx.moveTo(prev.x, prev.y);
            drawCtx.lineTo(x, y);
            drawCtx.stroke();
          }
        }
      }

      requestAnimationFrame(detect);
    }

    // ==========================
    // Toggle Writing Mode (W key)
    // ==========================
    window.addEventListener("keydown", (e) => {
      if (e.key.toLowerCase() === "w") {

        // ‚ùå indicator OFF hai to writing allow nahi
        if (!writeIndicatorON) return;

        drawing = !drawing;

        if (!drawing) {
          drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
        }

        stroke = [];

        smoothX = null;
        smoothY = null;
        medianBufferX = [];
        medianBufferY = [];
      }
    });



    // ==========================
    // CLEAR SCREEN BUTTON
    // ==========================
    window.clearScreen = function () {
      drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
      stroke = [];

      // üî• Reset filters
      smoothX = null;
      smoothY = null;
      medianBufferX = [];
      medianBufferY = [];
    };



    // ==========================
    // SEND AIR-WRITTEN STROKE TO BACKEND
    // ==========================
    async function sendStroke() {
      if (stroke.length < 2) {
        alert("No handwriting detected!");
        return;
      }

      const res = await fetch("/recognize", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ points: stroke }),
      });

      const data = await res.json();
      alert("Recognized: " + data.char);
    }
    window.goFullscreen = function () {
      const elem = document.querySelector(".wrap");


      if (!document.fullscreenElement) {
        elem.requestFullscreen().catch(err => {
          alert(`Error enabling fullscreen: ${err.message}`);
        });
      } else {
        document.exitFullscreen();
      }
    };


    init();
  </script>

</body>

</html>
<!-- // -->